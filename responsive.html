<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daffodil International University Artillery Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #1e293b; /* Slate-800 */
            color: #e0f2f1; /* Teal-100 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px; /* Reduced padding for mobile */
            margin: 0;
        }
        .game-container {
            max-width: 1024px;
            width: 100%;
            background-color: #0f172a; /* Slate-900 */
            border: 4px solid #06b6d4; /* Cyan-500 */
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(6, 182, 212, 0.5);
            padding: 16px;
        }
        #gameCanvas {
            border: 2px solid #06b6d4;
            background-color: #1a2b40; /* Dark blue sky */
            border-radius: 8px;
            touch-action: none; 
            /* Added min-height to prevent canvas from becoming a thin line on large screens */
            min-height: 300px; 
        }
        .input-group label {
            font-weight: 700;
            color: #22d3ee; /* Cyan-400 */
        }
        .btn-launch {
            background-color: #f43f5e; /* Rose-500 */
            color: white;
            transition: transform 0.1s;
        }
        .btn-launch:hover:not(:disabled) {
            background-color: #e11d48; /* Rose-600 */
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(244, 63, 94, 0.4);
        }
        .btn-launch:disabled {
            background-color: #475569; /* Slate-600 */
            cursor: not-allowed;
        }
        .control-panel {
            background-color: #1f2937; /* Gray-800 */
            border-radius: 8px;
        }
        .health-bar-bg {
            background-color: #334155;
            height: 12px;
            border-radius: 4px;
        }
        .health-bar-fill {
            transition: width 0.5s ease-in-out, background-color 0.5s;
        }
        .status-box {
            background-color: #1f2937; 
            border: 2px solid #3b82f6; 
        }
        /* Custom styles for mobile layout refinement */
        @media (max-width: 767px) {
            .control-panel > div {
                margin-bottom: 12px;
            }
            .control-panel {
                grid-template-columns: 1fr; /* Stack all columns on small screens */
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1 class="text-xl md:text-3xl text-center mb-4 text-cyan-400">ARTILLERY MOVING TARGET CHALLENGE</h1>

    <!-- Canvas maintains w-full, height is set by JS for aspect ratio -->
    <canvas id="gameCanvas" width="800" height="500" class="w-full"></canvas>

    <div class="control-panel p-4 mt-4 grid grid-cols-1 md:grid-cols-4 gap-4">
        
        <div class="flex flex-col space-y-2 order-1 md:order-1">
            <div class="text-base md:text-lg font-bold text-center text-emerald-300">Your Launcher</div>
            <div id="windDisplay" class="text-center text-yellow-300 text-sm">Wind: 0 m/s</div>
        </div>

        <div class="flex flex-col space-y-3 order-3 md:order-2">
            <div class="input-group">
                <label for="angleSlider" class="block text-sm">Angle: <span id="angleValue">45</span>Â°</label>
                <input type="range" id="angleSlider" min="10" max="170" value="45" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
            <div class="input-group">
                <label for="powerSlider" class="block text-sm">Projectile Speed (Power): <span id="powerValue">100</span></label>
                <input type="range" id="powerSlider" min="20" max="200" value="100" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>

        <div class="flex flex-col space-y-3 order-4 md:order-3">
            <div class="input-group">
                <label for="speedSlider" class="block text-sm">Target Speed: <span id="speedValue">50</span></label>
                <input type="range" id="speedSlider" min="10" max="100" value="50" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
            </div>
            <button id="launchButton" class="btn-launch p-3 rounded-lg text-lg font-bold uppercase">
                Launch Missile
            </button>
        </div>


        <div class="status-box p-3 rounded-lg flex flex-col justify-center text-center space-y-2 order-2 md:order-4">
            <div class="text-base md:text-xl font-bold text-teal-300">Moving Target Health</div>
            <div id="targetHealthContainer" class="health-bar-bg">
                <div id="targetHealth" class="health-bar-fill w-full bg-red-500" style="width: 100%;"></div>
            </div>
            <div id="messageBox" class="text-sm h-6">Ready to fire!</div>
            <button id="resetButton" class="bg-indigo-600 hover:bg-indigo-700 text-white p-2 rounded-lg text-sm transition hidden">
                New Game
            </button>
        </div>
    </div>
</div>

<script type="module">
    // --- SCALING CONSTANTS ---
    const ORIGINAL_WIDTH = 800;
    const ORIGINAL_HEIGHT = 500; 

    // --- CANVAS AND CONTEXT SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let WIDTH = ORIGINAL_WIDTH; // Current width, set by setupCanvas
    let HEIGHT = ORIGINAL_HEIGHT; // Current height, set by setupCanvas
    let GROUND_LEVEL = HEIGHT - 20; 

    // --- GAME CONSTANTS AND STATE (Initial values, will be scaled in draw functions) ---
    const G = 9.8; // Gravity (m/s^2) - Physical constant, not scaled.
    const COLLAPSE_SPEED = 0.05; 
    const MAX_HEALTH = 100;
    
    // Normalized dimensions (based on 800x500 grid)
    const NORM_PLAYER_BASE_WIDTH = 100;
    const NORM_PLAYER_BASE_HEIGHT = 250; 
    const NORM_AI_BASE_WIDTH = 100;
    const NORM_AI_BASE_HEIGHT = 180; 
    const NORM_PLAYER_X = 50;
    const NORM_AI_X_OFFSET = 50; // Distance from right edge

    let gameState = {
        targetHealth: MAX_HEALTH,
        wind: 0,
        isFiring: false,
        missile: null,
        gameStatus: 'active',
        targetOnFire: false,
    };

    // Define base positions and movement variables (x is dynamic, y is relative to height)
    let playerBase = {
        x: NORM_PLAYER_X,
        y: HEIGHT - NORM_PLAYER_BASE_HEIGHT,
        width: NORM_PLAYER_BASE_WIDTH,
        height: NORM_PLAYER_BASE_HEIGHT,
    };

    let aiBase = {
        x: WIDTH - NORM_AI_BASE_WIDTH - NORM_AI_X_OFFSET,
        y: HEIGHT - NORM_AI_BASE_HEIGHT, 
        width: NORM_AI_BASE_WIDTH,
        height: NORM_AI_BASE_HEIGHT,
        speed: 50, // Remains in m/s
        direction: -1, 
        isCollapsing: false,
        collapseProgress: 0,
        rubbleDrawn: false,
        minX: 0, // Calculated dynamically
        maxX: 0, // Calculated dynamically
    };

    // --- UI ELEMENTS ---
    const angleSlider = document.getElementById('angleSlider');
    const powerSlider = document.getElementById('powerSlider');
    const speedSlider = document.getElementById('speedSlider'); 
    const angleValueDisplay = document.getElementById('angleValue');
    const powerValueDisplay = document.getElementById('powerValue');
    const speedValueDisplay = document.getElementById('speedValue'); 
    const launchButton = document.getElementById('launchButton');
    const messageBox = document.getElementById('messageBox');
    const windDisplay = document.getElementById('windDisplay');
    let targetHealthEl = document.getElementById('targetHealth');
    const resetButton = document.getElementById('resetButton');
    
    // --- PHYSICS FUNCTIONS ---

    function calculatePosition(x0, y0, v0, angle, t, wind) {
        // NOTE: The game is drawn scaled, but the physics (v0, G, t, wind) remain in their real-world units (m/s, m/s^2) 
        // relative to the original 800x500 coordinate system to maintain simulation integrity.
        const vx = v0 * Math.cos(angle);
        const vy = v0 * Math.sin(angle);
        const x = x0 + (vx + wind) * t;
        const y = y0 - (vy * t - 0.5 * G * t * t);
        return { x, y };
    }
    
    // --- TARGET BASE MOVEMENT AND COLLAPSE UPDATE ---

    function updateAIBase(dt) {
        // Stop movement if the missile is in flight (gameState.isFiring) or if collapsing
        if (gameState.gameStatus !== 'active' || gameState.isFiring || aiBase.isCollapsing) {
            
            if (aiBase.isCollapsing) {
                // Animate the collapse
                aiBase.collapseProgress = Math.min(1, aiBase.collapseProgress + COLLAPSE_SPEED);
                if (aiBase.collapseProgress >= 1) {
                    aiBase.rubbleDrawn = true;
                    aiBase.isCollapsing = false;
                    gameState.gameStatus = 'player_win';
                    messageBox.textContent = 'TARGET DESTROYED! Press New Game.';
                }
            }
            return;
        }

        // Target Movement Logic (Only runs if game is active AND no missile in flight)
        aiBase.speed = parseFloat(speedSlider.value); 
        
        // Movement calculated in normalized coordinates (pixels per second in the 800px wide world)
        const dx = aiBase.speed * aiBase.direction * dt; 
        aiBase.x += dx;

        // Check boundaries in normalized coordinates
        if (aiBase.x < aiBase.minX) {
            aiBase.x = aiBase.minX;
            aiBase.direction = 1; 
        } else if (aiBase.x > aiBase.maxX) {
            aiBase.x = aiBase.maxX;
            aiBase.direction = -1; 
        }
    }

    // --- DRAWING FUNCTIONS ---
    
    function drawRocket(missile) {
        if (!missile) return;
        const scale = WIDTH / ORIGINAL_WIDTH;

        ctx.save();
        ctx.translate(missile.x * scale, missile.y * scale);

        // Calculate angle of flight path
        const vx = missile.v0 * Math.cos(missile.angleRad) + gameState.wind;
        const vy = missile.v0 * Math.sin(missile.angleRad) - G * missile.time;
        const currentAngleRad = Math.atan2(-vy, vx); 

        ctx.rotate(currentAngleRad);

        const L = 20 * scale; // Scaled length
        const W = 6 * scale; // Scaled width
        const bodyColor = '#94a3b8'; 
        const tipColor = '#ef4444'; 
        const engineColor = '#ff8c00'; 

        // 1. Engine/Flame 
        ctx.fillStyle = engineColor; 
        ctx.beginPath();
        ctx.moveTo(-L / 2, 0);
        ctx.lineTo(-L / 2 - (5 * scale), -W / 2);
        ctx.lineTo(-L / 2 - (5 * scale), W / 2);
        ctx.closePath();
        ctx.fill();

        // 2. Body
        ctx.fillStyle = bodyColor;
        ctx.fillRect(-L / 2, -W / 2, L - (5 * scale), W);

        // 3. Nose Cone
        ctx.fillStyle = tipColor;
        ctx.beginPath();
        ctx.moveTo(L / 2 - (5 * scale), -W / 2);
        ctx.lineTo(L / 2 - (5 * scale), W / 2);
        ctx.lineTo(L / 2, 0);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    function drawFireEffect(x, y, width, scale) {
        const fireHeight = aiBase.isCollapsing ? 60 * scale : 20 * scale; 
        const time = performance.now() / 100;
        
        for (let i = 0; i < 5; i++) {
            const flickerX = x + width * (i / 4) + (Math.sin(time + i) * 5 * scale);
            const flickerY = y - (Math.sin(time * 0.5 + i * 2) * fireHeight * 0.5) - fireHeight / 2;
            const radius = 5 * scale + (Math.cos(time * 0.8 + i) * 3 * scale);
            
            ctx.fillStyle = `rgba(255, 165, 0, ${0.8 + Math.random() * 0.2})`;
            ctx.beginPath();
            ctx.arc(flickerX, flickerY, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = `rgba(255, 69, 0, ${0.5 + Math.random() * 0.1})`;
            ctx.beginPath();
            ctx.arc(flickerX, flickerY, radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = 'rgba(100, 100, 100, 0.6)'; // Smoke
        for (let i = 0; i < 3; i++) {
            const smokeX = x + width * (i / 2) - 10 * scale;
            const smokeY = y - fireHeight - 5 * scale;
            const smokeRadius = 10 * scale + (Math.sin(time * 0.4 + i * 3) * 5 * scale);
            
            ctx.beginPath();
            ctx.arc(smokeX, smokeY, smokeRadius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    function drawRubble(x, y, width, scale) {
        // Draws a small pile of debris on the ground
        ctx.fillStyle = '#64748b'; // Gray rubble color
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + width * 0.1, y - 5 * scale);
        ctx.lineTo(x + width * 0.3, y - 10 * scale);
        ctx.lineTo(x + width * 0.6, y - 4 * scale);
        ctx.lineTo(x + width * 0.9, y - 7 * scale);
        ctx.lineTo(x + width, y);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = '#8b0000'; // Darker red remnants of old building
        ctx.fillRect(x + width/4, y - 2 * scale, width/8, 2 * scale);
        ctx.fillRect(x + width/2, y - 3 * scale, width/10, 3 * scale);
    }


    function drawBuildings() {
        const scale = WIDTH / ORIGINAL_WIDTH;

        // --- Player Base (Daffodil International University Launcher) ---
        const playerX = playerBase.x * scale;
        const playerY = playerBase.y * scale;
        const playerWidth = playerBase.width * scale;
        const playerHeight = playerBase.height * scale;

        // Base rectangle
        const gradient = ctx.createLinearGradient(playerX, playerY, playerX + playerWidth, playerY + playerHeight);
        gradient.addColorStop(0, '#0ea5e9'); // Sky-500
        gradient.addColorStop(1, '#0284c7'); // Sky-600
        ctx.fillStyle = gradient;
        ctx.fillRect(playerX, playerY, playerWidth, playerHeight);

        // Pitched roof
        ctx.fillStyle = '#06b6d4'; // Cyan-500
        ctx.beginPath();
        ctx.moveTo(playerX - (10 * scale), playerY);
        ctx.lineTo(playerX + playerWidth / 2, playerY - (40 * scale)); // Peak
        ctx.lineTo(playerX + playerWidth + (10 * scale), playerY);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#0e7490'; // Cyan-700 for roof outline
        ctx.lineWidth = 2 * scale;
        ctx.stroke();

        // Windows
        ctx.fillStyle = '#a7f3d0'; // Emerald-200
        for(let i = 0; i < 2; i++) { // Two columns of windows
            for(let j = 0; j < Math.floor(playerHeight / (50 * scale)); j++) {
                const windowY = playerY + (15 + j * 45) * scale;
                if (windowY + 30 * scale < GROUND_LEVEL * scale - 20 * scale) { // Window bounds check
                    ctx.fillRect(playerX + (15 + i * 40) * scale, windowY, 20 * scale, 30 * scale);
                }
            }
        }
        
        // Draw "Daffodil International University" text above the base
        ctx.fillStyle = '#e0f2f1'; 
        ctx.textAlign = 'center';
        ctx.font = `bold ${Math.round(16 * scale)}px Orbitron`;
        ctx.fillText("Daffodil International", playerX + playerWidth / 2, playerY - (70 * scale)); 
        ctx.fillText("University", playerX + playerWidth / 2, playerY - (50 * scale)); 
        
        

        // Draw Player Cannon
        drawCannon(playerX + playerWidth, playerY, angleSlider.value, scale);

        // --- Target Base (Moving Victim - City University - Old School/Vintage) ---

        let renderX = aiBase.x * scale;
        let renderY = aiBase.y * scale;
        let renderWidth = aiBase.width * scale;
        let renderHeight = aiBase.height * scale;
        const scaledGround = GROUND_LEVEL * scale;


        if (aiBase.rubbleDrawn) {
            // Draw Rubble
            drawRubble(renderX, scaledGround, renderWidth, scale);
            
            // Draw "City destroyed" text above the rubble
            ctx.fillStyle = '#f43f5e';
            ctx.textAlign = 'center';
            ctx.font = `bold ${Math.round(24 * scale)}px Orbitron`;
            ctx.fillText("City destroyed", renderX + renderWidth / 2, scaledGround - (50 * scale));

        } else {
            

            if (aiBase.isCollapsing) {
                const progress = aiBase.collapseProgress; 
                renderHeight = aiBase.height * (1 - progress) * scale; 
                renderY = scaledGround - renderHeight;
            }
            
            // Main building body - muted red/brown for vintage feel
            ctx.fillStyle = '#b91c1c'; // Red-700
            ctx.fillRect(renderX, renderY, renderWidth, renderHeight);

            // Roof - flat, dark, a bit overhang
            ctx.fillStyle = '#440000'; // Darker red/brown for roof
            ctx.fillRect(renderX - (5 * scale), renderY - (10 * scale), renderWidth + (10 * scale), 10 * scale);
            
            // Windows - simple, square, distinct
            ctx.fillStyle = '#a8a29e'; // Stone-400
            for(let i = 0; i < 2; i++) { 
                for(let j = 0; j < Math.floor(renderHeight / (40 * scale)); j++) {
                    const windowY = renderY + (10 + j * 35) * scale;
                    if (windowY + 25 * scale < scaledGround - 10 * scale) {
                        ctx.fillRect(renderX + (15 + i * 40) * scale, windowY, 20 * scale, 25 * scale);
                    }
                }
            }

            // Draw Target Text (only when not collapsed)
            ctx.fillStyle = '#fef3c7'; 
            ctx.textAlign = 'center';
            ctx.font = `bold ${Math.round(18 * scale)}px Orbitron`;
            ctx.fillText("City", renderX + renderWidth / 2, renderY - (40 * scale)); 
            ctx.font = `bold ${Math.round(16 * scale)}px Orbitron`; 
            ctx.fillText("University", renderX + renderWidth / 2, renderY - (20 * scale)); 

            // Draw Fire Effect if target is hit OR collapsing
            if (gameState.targetOnFire || aiBase.isCollapsing) {
                drawFireEffect(renderX, renderY, renderWidth, scale);
            }
        }
    }

    function drawCannon(x, y, angleDeg, scale) { 
        ctx.save();
        ctx.translate(x, y);
        const angleRad = angleDeg * (Math.PI / 180);
        ctx.rotate(-angleRad); 

        // Base/Mount (wider part)
        ctx.fillStyle = '#475569'; // Slate-600
        ctx.fillRect(-10 * scale, -8 * scale, 20 * scale, 16 * scale); 
        ctx.beginPath();
        ctx.arc(0, 0, 8 * scale, 0, Math.PI * 2); // Central pivot
        ctx.fill();

        // Barrel (more robust)
        const barrelLength = 45 * scale;
        const barrelWidth = 10 * scale;
        const barrelGradient = ctx.createLinearGradient(0, -barrelWidth / 2, barrelLength, barrelWidth / 2);
        barrelGradient.addColorStop(0, '#64748b'); // Slate-500
        barrelGradient.addColorStop(1, '#94a3b8'); // Slate-400
        ctx.fillStyle = barrelGradient;
        ctx.fillRect(0, -barrelWidth / 2, barrelLength, barrelWidth);

        // Barrel opening (for visual depth)
        ctx.fillStyle = '#1e293b'; // Darker for inside
        ctx.fillRect(barrelLength - (5 * scale), -barrelWidth / 4, 5 * scale, barrelWidth / 2);

        ctx.restore();
    }

    function drawPredictionLine(x0, y0, v0, angleDeg) {
        const scale = WIDTH / ORIGINAL_WIDTH;
        const angleRad = angleDeg * (Math.PI / 180);
        const wind = gameState.wind;
        
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1 * scale;
        ctx.setLineDash([5 * scale, 5 * scale]); // Scale the dashes

        let t = 0;
        const dt = 0.1;

        let pos = {x: x0, y: y0};
        ctx.moveTo(pos.x * scale, pos.y * scale);

        for (let i = 0; i < 50; i++) {
            t += dt;
            // Physics calculation remains in normalized coordinates
            pos = calculatePosition(x0, y0, v0, angleRad, t, wind); 
            
            if (pos.y * scale > GROUND_LEVEL * scale) break;
            if (pos.x * scale < 0 || pos.x * scale > WIDTH) break;
            
            ctx.lineTo(pos.x * scale, pos.y * scale);
        }

        ctx.stroke();
        ctx.setLineDash([]);
    }

    function drawGround() {
        const scale = WIDTH / ORIGINAL_WIDTH;
        ctx.fillStyle = '#4f46e5'; 
        ctx.fillRect(0, GROUND_LEVEL * scale, WIDTH, 20 * scale);
    }

    function drawWind() {
        const scale = WIDTH / ORIGINAL_WIDTH;
        const windX = WIDTH / 2;
        const windY = 40 * scale;
        const magnitude = Math.abs(gameState.wind);
        
        if (magnitude < 1) return;

        const arrowLength = (50 + magnitude * 5) * scale;
        const direction = gameState.wind > 0 ? 1 : -1;

        ctx.strokeStyle = '#facc15';
        ctx.fillStyle = '#facc15';
        ctx.lineWidth = 3 * scale;
        
        ctx.beginPath();
        ctx.moveTo(windX - arrowLength / 2, windY);
        ctx.lineTo(windX + arrowLength / 2, windY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(windX + direction * arrowLength / 2, windY);
        ctx.lineTo(windX + direction * (arrowLength / 2 - 10 * scale), windY - 5 * scale);
        ctx.lineTo(windX + direction * (arrowLength / 2 - 10 * scale), windY + 5 * scale);
        ctx.closePath();
        ctx.fill();
    }

    function drawGameOver() {
        resetButton.classList.remove('hidden');
    }

    // --- GAME LOOP & UPDATES ---

    let lastTime = 0;
    function gameLoop(currentTime) {
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // 1. Clear Canvas
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        drawGround();

        // 2. Update Missile Physics
        if (gameState.isFiring && gameState.missile) {
            updateMissile(deltaTime);
        }
        
        // 3. Update Moving Target Base position or Collapse state
        updateAIBase(deltaTime);

        // 4. Draw Game Elements
        drawBuildings();
        drawRocket(gameState.missile);
        drawWind();
        
        // Draw the prediction line based on current slider values
        if (!gameState.isFiring && gameState.gameStatus === 'active' && !aiBase.isCollapsing) {
            const angleDeg = parseFloat(angleSlider.value);
            const power = parseFloat(powerSlider.value);
            // Use normalized coordinates for physics calculation
            drawPredictionLine(
                playerBase.x + playerBase.width + 10, 
                playerBase.y - 5, 
                power, 
                angleDeg
            );
        }

        // 5. Draw Game Over state (show reset button)
        if (gameState.gameStatus !== 'active' && aiBase.rubbleDrawn) {
            drawGameOver();
        }

        requestAnimationFrame(gameLoop);
    }

    function updateMissile(dt) {
        const m = gameState.missile;
        m.time += dt;

        // Position calculated in normalized coordinates
        const newPos = calculatePosition(
            m.x0, m.y0, m.v0, m.angleRad, m.time, gameState.wind
        );
        m.x = newPos.x;
        m.y = newPos.y;

        // Collision Check uses normalized coordinates
        if (checkBuildingCollision(m.x, m.y)) {
            handleHit();
            return; 
        }

        // Termination conditions: Off-screen or hits the ground level
        if (m.y >= GROUND_LEVEL || m.x < 0 || m.x > ORIGINAL_WIDTH) { // Use ORIGINAL_WIDTH for bounds check
            handleImpact(m.x, newPos.y);
        }
    }

    function checkBuildingCollision(x, y) {
        if (!gameState.isFiring || aiBase.isCollapsing) return false;

        // Collision Check: Missile is within the horizontal range AND within the vertical height of the building
        // All checks are performed in the normalized (800x500) coordinate system
        const isHit = x >= aiBase.x && 
                      x <= aiBase.x + aiBase.width && 
                      y >= aiBase.y && 
                      y <= GROUND_LEVEL;

        return isHit;
    }
    
    function handleHit() {
        gameState.isFiring = false;
        gameState.missile = null;
        launchButton.disabled = true;

        // Trigger Instant Collapse Logic
        gameState.targetHealth = 0; 
        gameState.targetOnFire = true; 
        aiBase.isCollapsing = true;
        
        messageBox.textContent = 'DIRECT HIT! City University is collapsing!';
        updateHealthDisplay();
        
        setTimeout(() => gameState.targetOnFire = false, 1500); 
    }

    function handleImpact(x, y) {
        gameState.isFiring = false;
        gameState.missile = null;
        
        // Only enable the launch button if the building hasn't been destroyed
        if (gameState.gameStatus === 'active') {
            launchButton.disabled = false;
            messageBox.textContent = 'Miss! The target is safe... for now.';
        }
    }

    // --- GAME CONTROL FUNCTIONS ---

    function newGame() {
        gameState.targetHealth = MAX_HEALTH;
        gameState.isFiring = false;
        gameState.missile = null;
        gameState.gameStatus = 'active';
        gameState.targetOnFire = false;
        
        // Reset AI Base properties including collapse state
        aiBase.x = WIDTH - NORM_AI_BASE_WIDTH - NORM_AI_X_OFFSET; // Recalculate start X position in normalized coords
        aiBase.direction = -1; 
        aiBase.isCollapsing = false;
        aiBase.collapseProgress = 0;
        aiBase.rubbleDrawn = false;
        
        // Generate new random wind (-15 to 15 m/s)
        gameState.wind = parseFloat((Math.random() * 30 - 15).toFixed(1));
        
        updateHealthDisplay();
        updateUI();
        
        launchButton.disabled = false;
        resetButton.classList.add('hidden');
        messageBox.textContent = 'A new challenge begins! Hit the moving target.';
    }
    
    function updateHealthDisplay() {
        const targetPercent = (gameState.targetHealth / MAX_HEALTH) * 100;
        
        targetHealthEl.style.width = `${targetPercent}%`;
        targetHealthEl.style.backgroundColor = targetPercent > 50 ? '#10b981' : (targetPercent > 20 ? '#fbbf24' : '#ef4444');
    }

    function updateUI() {
        windDisplay.textContent = `Wind: ${gameState.wind.toFixed(1)} m/s (${gameState.wind > 0 ? 'Right' : (gameState.wind < 0 ? 'Left' : 'Calm')})`;
    }

    // --- LAUNCH HANDLER ---
    
    function playerFire() {
        if (gameState.isFiring || gameState.gameStatus !== 'active') return;
        
        gameState.isFiring = true;
        launchButton.disabled = true;
        messageBox.textContent = 'MISSILE LAUNCHED! Target movement halted.';

        const angleDeg = parseFloat(angleSlider.value);
        const power = parseFloat(powerSlider.value);
        const angleRad = angleDeg * (Math.PI / 180);

        // Normalized launch point (in the 800x500 coordinate system)
        const launchX0 = playerBase.x + playerBase.width + 10;
        const launchY0 = playerBase.y - 5; 

        gameState.missile = {
            x: launchX0, 
            y: launchY0,
            x0: launchX0,
            y0: launchY0,
            v0: power,
            angleRad: angleRad,
            angleDeg: angleDeg,
            time: 0,
        };
    }

    // --- EVENT LISTENERS ---

    // Sliders
    angleSlider.addEventListener('input', () => {
        angleValueDisplay.textContent = angleSlider.value;
    });
    powerSlider.addEventListener('input', () => {
        powerValueDisplay.textContent = powerSlider.value;
    });
    speedSlider.addEventListener('input', () => { 
        speedValueDisplay.textContent = speedSlider.value;
    });

    // Launch Button
    launchButton.addEventListener('click', playerFire);
    
    // Reset Button
    resetButton.addEventListener('click', newGame);
    
    // Initial setup and start
    window.onload = function() {
        const setupCanvas = () => {
            const canvasContainer = document.querySelector('.game-container');
            
            // Set canvas size based on container width
            WIDTH = canvasContainer.clientWidth - 32; // -32 for padding
            // Maintain aspect ratio 800:500 (1.6)
            HEIGHT = WIDTH / (ORIGINAL_WIDTH / ORIGINAL_HEIGHT); 

            // Clamp maximum size
            if (WIDTH > ORIGINAL_WIDTH) {
                WIDTH = ORIGINAL_WIDTH;
                HEIGHT = ORIGINAL_HEIGHT;
            } else if (WIDTH < 300) {
                 // Ensure minimum size for visibility on tiny screens
                WIDTH = canvasContainer.clientWidth - 32;
                HEIGHT = WIDTH / (ORIGINAL_WIDTH / ORIGINAL_HEIGHT);
            }

            canvas.width = WIDTH;
            canvas.height = HEIGHT;

            // Recalculate Normalized Coordinates for non-drawing variables
            GROUND_LEVEL = ORIGINAL_HEIGHT - 20; 
            playerBase.y = ORIGINAL_HEIGHT - NORM_PLAYER_BASE_HEIGHT;
            
            // The AI base position and boundaries are defined in the normalized 800x500 grid
            aiBase.width = NORM_AI_BASE_WIDTH;
            aiBase.height = NORM_AI_BASE_HEIGHT;
            aiBase.minX = ORIGINAL_WIDTH / 2 + 20;
            aiBase.maxX = ORIGINAL_WIDTH - NORM_AI_BASE_WIDTH - 20;
            
            // Ensure AI Base X coordinate is within new boundaries after resize
            if (aiBase.x < aiBase.minX || aiBase.x > aiBase.maxX) {
                aiBase.x = aiBase.maxX;
            }
        }

        setupCanvas();
        newGame();
        requestAnimationFrame(gameLoop);
        
        window.addEventListener('resize', setupCanvas);
    };
    
</script>
</body>
</html>
